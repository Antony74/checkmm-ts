{"version":3,"file":"checkmm.js","mappings":"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","sources":["webpack://checkmm/./src/checkmm.ts","webpack://checkmm/./src/std.ts","webpack://checkmm/external node-commonjs \"fs\"","webpack://checkmm/external node-commonjs \"path\"","webpack://checkmm/external node-commonjs \"util\"","webpack://checkmm/webpack/bootstrap","webpack://checkmm/webpack/startup"],"sourcesContent":["\"use strict\";\n// Metamath database verifier\n// Antony Bartlett (akb@akb.me.uk)\n//\n// I release this code to the public domain under the\n// Creative Commons \"CC0 1.0 Universal\" Public Domain Dedication:\n//\n// http://creativecommons.org/publicdomain/zero/1.0/\n//\n// This is a port to TypeScript.  The original C++ program was\n// written by Eric Schmidt and can be found here:\n// http://us.metamath.org/other.html#checkmm\n//\n// This is a standalone verifier for Metamath database files.\n// Run it with a single file name as the parameter.\n//\n// Some notes:\n//\n// The code assumes that the character set is compatible with ASCII.\n//\n// According to the spec, file inclusion commands should not include a file\n// that has already been included. Unfortunately, determing whether two\n// different strings refer to the same file is not easy, and, worse, is\n// system-dependant. This program ignores the issue entirely and assumes\n// that distinct strings name different files. This should be adequate for\n// the present, at least.\n//\n// If the verifier finds an error, it will report it and quit. It will not\n// attempt to recover and find more errors. The only condition that generates\n// a diagnostic message but doesn't halt the program is an incomplete proof,\n// specified by a question mark. In that case, as per the spec, a warning is\n// issued and checking continues.\n//\n// Please let me know of any bugs.\n// https://github.com/Antony74/checkmm-ts/issues\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Scope = exports.Assertion = void 0;\nconst path_1 = __importDefault(require(\"path\"));\nconst std_1 = __importStar(require(\"./std\"));\nlet tokens = [];\nlet constants = new Set();\nlet hypotheses = new Map();\nlet variables = new Set();\n// An axiom or a theorem.\nclass Assertion {\n    constructor() {\n        // Hypotheses of this axiom or theorem.\n        this.hypotheses = [];\n        this.disjvars = new Set();\n        // Statement of axiom or theorem.\n        this.expression = [];\n    }\n}\nexports.Assertion = Assertion;\nlet assertions = new Map();\nclass Scope {\n    constructor() {\n        this.activevariables = new Set();\n        // Labels of active hypotheses\n        this.activehyp = [];\n        this.disjvars = [];\n        // Map from variable to label of active floating hypothesis\n        this.floatinghyp = new Map();\n    }\n}\nexports.Scope = Scope;\nlet scopes = new Array();\n// Determine if a string is used as a label\nlet labelused = (label) => {\n    return hypotheses.get(label) !== undefined || assertions.get(label) !== undefined;\n};\n// Find active floating hypothesis corresponding to variable, or empty string\n// if there isn't one.\nlet getfloatinghyp = (vari) => {\n    for (const scope of scopes) {\n        const loc = scope.floatinghyp.get(vari);\n        if (loc !== undefined)\n            return loc;\n    }\n    return '';\n};\n// Determine if a string is an active variable.\nlet isactivevariable = (str) => {\n    for (const scope of scopes) {\n        if (scope.activevariables.has(str))\n            return true;\n    }\n    return false;\n};\n// Determine if a string is the label of an active hypothesis.\nlet isactivehyp = (str) => {\n    for (const scope of scopes) {\n        if (scope.activehyp.find(_str => str === _str))\n            return true;\n    }\n    return false;\n};\n// Determine if there is an active disjoint variable restriction on\n// two different variables.\nlet isdvr = (var1, var2) => {\n    if (var1 === var2)\n        return false;\n    for (const scope of scopes) {\n        for (const disjvar of scope.disjvars) {\n            if (disjvar.has(var1) && disjvar.has(var2))\n                return true;\n        }\n    }\n    return false;\n};\n// Determine if a character is white space in Metamath.\nlet ismmws = (ch) => {\n    // This doesn't include \\v (\"vertical tab\"), as the spec omits it.\n    return ch === ' ' || ch === '\\n' || ch === '\\t' || ch === '\\f' || ch === '\\r';\n};\n// Determine if a token is a label token.\nlet islabeltoken = (token) => {\n    for (const ch of token) {\n        if (!(std_1.default.isalnum(ch) || ch === '.' || ch === '-' || ch === '_'))\n            return false;\n    }\n    return true;\n};\n// Determine if a token is a math symbol token.\nlet ismathsymboltoken = (token) => {\n    return !token.includes('$');\n};\n// Determine if a token consists solely of upper-case letters or question marks\nlet containsonlyupperorq = (token) => {\n    for (const ch of token) {\n        if (!std_1.default.isupper(ch) && ch !== '?')\n            return false;\n    }\n    return true;\n};\nlet nexttoken = (input) => {\n    let ch;\n    let token = '';\n    // Skip whitespace\n    while (!!(ch = input.get()) && ismmws(ch)) { }\n    if (input.good())\n        input.unget();\n    // Get token\n    while (!!(ch = input.get()) && !ismmws(ch)) {\n        if (ch < '!' || ch > '~') {\n            console.error('Invalid character read with code 0x' + ch.charCodeAt(0).toString(16));\n            return '';\n        }\n        token += ch;\n    }\n    if (!input.eof() && input.fail())\n        return '';\n    return token;\n};\nconst mmfilenames = new Set();\nlet readtokens = (filename) => __awaiter(void 0, void 0, void 0, function* () {\n    const alreadyencountered = mmfilenames.has(filename);\n    if (alreadyencountered)\n        return true;\n    mmfilenames.add(filename);\n    let instream = undefined;\n    try {\n        instream = yield std_1.default.ifstream(filename);\n    }\n    catch (_e) { }\n    if (!instream) {\n        console.error('Could not open ' + filename);\n        return false;\n    }\n    let incomment = false;\n    let infileinclusion = false;\n    let newfilename = '';\n    let token;\n    while ((token = nexttoken(instream)).length) {\n        if (incomment) {\n            if (token === '$)') {\n                incomment = false;\n                continue;\n            }\n            if (token.includes('$(')) {\n                console.error('Characters $( found in a comment');\n                return false;\n            }\n            if (token.includes('$)')) {\n                console.error('Characters $) found in a comment');\n                return false;\n            }\n            continue;\n        }\n        // Not in comment\n        if (token === '$(') {\n            incomment = true;\n            continue;\n        }\n        if (infileinclusion) {\n            if (!newfilename.length) {\n                if (token.includes('$')) {\n                    console.error('Filename ' + token + ' contains a $');\n                    return false;\n                }\n                if (path_1.default) {\n                    newfilename = path_1.default.normalize(path_1.default.join(path_1.default.dirname(filename), token));\n                }\n                else {\n                    newfilename = token;\n                }\n                continue;\n            }\n            else {\n                if (token !== '$]') {\n                    console.error(\"Didn't find closing file inclusion delimiter\");\n                    return false;\n                }\n                const okay = yield readtokens(newfilename);\n                if (!okay)\n                    return false;\n                infileinclusion = false;\n                newfilename = '';\n                continue;\n            }\n        }\n        if (token === '$[') {\n            infileinclusion = true;\n            continue;\n        }\n        tokens.push(token);\n    }\n    if (!instream.eof()) {\n        if (instream.fail())\n            console.error('Error reading from ' + filename);\n        return false;\n    }\n    if (incomment) {\n        console.error('Unclosed comment');\n        return false;\n    }\n    if (infileinclusion) {\n        console.error('Unfinished file inclusion command');\n        return false;\n    }\n    return true;\n});\n// Construct an Assertion from an Expression. That is, determine the\n// mandatory hypotheses and disjoint variable restrictions.\n// The Assertion is inserted into the assertions collection,\n// and is returned by reference.\nlet constructassertion = (label, exp) => {\n    const assertion = new Assertion();\n    assertions.set(label, assertion);\n    assertion.expression = exp;\n    const varsused = new Set();\n    // Determine variables used and find mandatory hypotheses\n    for (const e of exp) {\n        if (variables.has(e))\n            varsused.add(e);\n    }\n    for (const scope of scopes.slice().reverse()) {\n        const hypvec = scope.activehyp;\n        for (const item2 of hypvec.slice().reverse()) {\n            const hyp = hypotheses.get(item2);\n            if (hyp.second && varsused.has(hyp.first[1])) {\n                // Mandatory floating hypothesis\n                assertion.hypotheses.unshift(item2);\n            }\n            else if (!hyp.second) {\n                // Essential hypothesis\n                assertion.hypotheses.unshift(item2);\n                for (const item3 of hyp.first) {\n                    if (variables.has(item3))\n                        varsused.add(item3);\n                }\n            }\n        }\n    }\n    // Determine mandatory disjoint variable restrictions\n    for (const scope of scopes) {\n        const disjvars = scope.disjvars;\n        for (const item2 of disjvars) {\n            const dset = Array.from(std_1.default.set_intersection(item2, varsused));\n            for (let index = 0; index < dset.length; ++index) {\n                for (let index2 = index + 1; index2 < dset.length; ++index2) {\n                    assertion.disjvars.add({ first: dset[index], second: dset[index2] });\n                }\n            }\n        }\n    }\n    return assertion;\n};\n// Read an expression from the token stream. Returns true iff okay.\nlet readexpression = (stattype, label, terminator) => {\n    if (!tokens.length) {\n        console.error('Unfinished $' + stattype + ' statement ' + label);\n        return undefined;\n    }\n    const type = tokens[tokens.length - 1];\n    if (!constants.has(type)) {\n        console.error('First symbol in $' + stattype + ' statement ' + label + ' is ' + type + ' which is not a constant');\n        return undefined;\n    }\n    tokens.pop();\n    const exp = [type];\n    let token;\n    while (tokens.length && (token = tokens[tokens.length - 1]) !== terminator) {\n        tokens.pop();\n        if (!constants.has(token) && !getfloatinghyp(token).length) {\n            console.error('In $' +\n                stattype +\n                ' statement ' +\n                label +\n                ' token ' +\n                token +\n                ' found which is not a constant or variable in an' +\n                ' active $f statement');\n            return undefined;\n        }\n        exp.push(token);\n    }\n    if (!tokens.length) {\n        console.error('Unfinished $' + stattype + ' statement ' + label);\n        return undefined;\n    }\n    tokens.pop(); // Discard terminator token\n    return exp;\n};\n// Make a substitution of variables. The result is put in \"destination\",\n// which should be empty.\nlet makesubstitution = (original, substmap) => {\n    let destination = [];\n    for (const item of original) {\n        const item2 = substmap.get(item);\n        if (!item2) {\n            // Constant\n            destination.push(item);\n        }\n        else {\n            // Variable\n            destination = [...destination, ...item2];\n        }\n    }\n    return destination;\n};\n// Get the raw numbers from compressed proof format.\n// The letter Z is translated as 0.\nlet getproofnumbers = (label, proof) => {\n    const proofnumbers = [];\n    let num = 0;\n    let justgotnum = false;\n    for (const item of proof) {\n        if (item <= 'T') {\n            const addval = item.charCodeAt(0) - ('A'.charCodeAt(0) - 1);\n            if (num > Number.MAX_SAFE_INTEGER / 20 || 20 * num > Number.MAX_SAFE_INTEGER - addval) {\n                console.error('Overflow computing numbers in compressed proof of ' + label);\n                return undefined;\n            }\n            proofnumbers.push(20 * num + addval);\n            num = 0;\n            justgotnum = true;\n        }\n        else if (item <= 'Y') {\n            const addval = item.charCodeAt(0) - 'T'.charCodeAt(0);\n            if (num > Number.MAX_SAFE_INTEGER / 5 || 5 * num > Number.MAX_SAFE_INTEGER - addval) {\n                console.error('Overflow computing numbers in compressed proof of ' + label);\n                return undefined;\n            }\n            num = 5 * num + addval;\n            justgotnum = false;\n        } // It must be Z\n        else {\n            if (!justgotnum) {\n                console.error('Stray Z found in compressed proof of ' + label);\n                return undefined;\n            }\n            proofnumbers.push(0);\n            justgotnum = false;\n        }\n    }\n    if (num !== 0) {\n        console.error('Compressed proof of theorem ' + label + ' ends in unfinished number');\n        return undefined;\n    }\n    return proofnumbers;\n};\n// Subroutine for proof verification. Verify a proof step referencing an\n// assertion (i.e., not a hypothesis).\nlet verifyassertionref = (thlabel, reflabel, stack) => {\n    const assertion = assertions.get(reflabel);\n    if (stack.size() < assertion.hypotheses.length) {\n        console.error('In proof of theorem ' + thlabel + ' not enough items found on stack');\n        return undefined;\n    }\n    const base = stack.size() - assertion.hypotheses.length;\n    const substitutions = new Map();\n    // Determine substitutions and check that we can unify\n    for (let i = 0; i < assertion.hypotheses.length; ++i) {\n        const hypothesis = hypotheses.get(assertion.hypotheses[i]);\n        if (hypothesis.second) {\n            // Floating hypothesis of the referenced assertion\n            if (hypothesis.first[0] !== stack.at(base + i)[0]) {\n                console.error('In proof of theorem ' + thlabel + ' unification failed');\n                return undefined;\n            }\n            const subst = stack.at(base + i).slice(1);\n            substitutions.set(hypothesis.first[1], subst);\n        }\n        else {\n            // Essential hypothesis\n            const dest = makesubstitution(hypothesis.first, substitutions);\n            if (!std_1.default.arraysequal(dest, stack.at(base + i))) {\n                console.error('In proof of theorem ' + thlabel + ' unification failed');\n                return undefined;\n            }\n        }\n    }\n    // Remove hypotheses from stack\n    stack.truncate(base);\n    // Verify disjoint variable conditions\n    for (const item of assertion.disjvars) {\n        const exp1 = substitutions.get(item.first);\n        const exp2 = substitutions.get(item.second);\n        const exp1vars = new Set();\n        for (const exp1item of exp1) {\n            if (variables.has(exp1item))\n                exp1vars.add(exp1item);\n        }\n        const exp2vars = new Set();\n        for (const exp2item of exp2) {\n            if (variables.has(exp2item))\n                exp2vars.add(exp2item);\n        }\n        for (const exp1item of exp1vars) {\n            for (const exp2item of exp2vars) {\n                if (!isdvr(exp1item, exp2item)) {\n                    console.error('In proof of theorem ' + thlabel + ' disjoint variable restriction violated');\n                    return undefined;\n                }\n            }\n        }\n    }\n    // Done verification of this step. Insert new statement onto stack.\n    const dest = makesubstitution(assertion.expression, substitutions);\n    stack.push(dest);\n    return stack;\n};\n// Verify a regular proof. The \"proof\" argument should be a non-empty sequence\n// of valid labels. Return true iff the proof is correct.\nlet verifyregularproof = (label, theorem, proof) => {\n    let stack = std_1.default.createStack();\n    for (const proofstep of proof) {\n        // If step is a hypothesis, just push it onto the stack.\n        const hyp = hypotheses.get(proofstep);\n        if (hyp) {\n            stack.push(hyp.first);\n            continue;\n        }\n        // It must be an axiom or theorem\n        stack = verifyassertionref(label, proofstep, stack);\n        if (stack === undefined)\n            return false;\n    }\n    if (stack.size() !== 1) {\n        console.error('Proof of theorem ' + label + ' does not end with only one item on the stack');\n        return false;\n    }\n    if (!std_1.default.arraysequal(stack.at(0), theorem.expression)) {\n        console.error('Proof of theorem ' + label + ' proves wrong statement');\n        return false;\n    }\n    return true;\n};\n// Verify a compressed proof\nlet verifycompressedproof = (label, theorem, labels, proofnumbers) => {\n    let stack = (0, std_1.createStack)();\n    const mandhypt = theorem.hypotheses.length;\n    const labelt = mandhypt + labels.length;\n    const savedsteps = [];\n    for (const item of proofnumbers) {\n        // Save the last proof step if 0\n        if (item === 0) {\n            savedsteps.push(stack.top());\n            continue;\n        }\n        // If step is a mandatory hypothesis, just push it onto the stack.\n        if (item <= mandhypt) {\n            stack.push(hypotheses.get(theorem.hypotheses[item - 1]).first);\n        }\n        else if (item <= labelt) {\n            const proofstep = labels[item - mandhypt - 1];\n            // If step is a (non-mandatory) hypothesis,\n            // just push it onto the stack.\n            const hyp = hypotheses.get(proofstep);\n            if (hyp) {\n                stack.push(hyp.first);\n                continue;\n            }\n            // It must be an axiom or theorem\n            stack = verifyassertionref(label, proofstep, stack);\n            if (stack === undefined)\n                return false;\n        } // Must refer to saved step\n        else {\n            if (item > labelt + savedsteps.length) {\n                console.error('Number in compressed proof of ' + label + ' is too high');\n                return false;\n            }\n            stack.push(savedsteps[item - labelt - 1]);\n        }\n    }\n    if (stack.size() !== 1) {\n        console.error('Proof of theorem ' + label + ' does not end with only one item on the stack');\n        return false;\n    }\n    if (!std_1.default.arraysequal(stack.at(0), theorem.expression)) {\n        console.error('Proof of theorem ' + label + ' proves wrong statement');\n        return false;\n    }\n    return true;\n};\n// Parse $p statement. Return true iff okay.\nlet parsep = (label) => {\n    const newtheorem = readexpression('p', label, '$=');\n    if (!newtheorem) {\n        return false;\n    }\n    const assertion = constructassertion(label, newtheorem);\n    // Now for the proof\n    if (!tokens.length) {\n        console.error('Unfinished $p statement ' + label);\n        return false;\n    }\n    if (tokens[tokens.length - 1] === '(') {\n        // Compressed proof\n        tokens.pop();\n        // Get labels\n        const labels = [];\n        let token;\n        while (tokens.length && (token = tokens[tokens.length - 1]) !== ')') {\n            tokens.pop();\n            labels.push(token);\n            if (token === label) {\n                console.error('Proof of theorem ' + label + ' refers to itself');\n                return false;\n            }\n            else if (assertion.hypotheses.find(_token => _token === token)) {\n                console.error('Compressed proof of theorem ' + label + ' has mandatory hypothesis ' + token + ' in label list');\n                return false;\n            }\n            else if (!assertions.has(token) && !isactivehyp(token)) {\n                console.error('Proof of theorem ' + label + ' refers to ' + token + ' which is not an active statement');\n                return false;\n            }\n        }\n        if (!tokens.length) {\n            console.error('Unfinished $p statement ' + label);\n            return false;\n        }\n        tokens.pop(); // Discard ) token\n        // Get proof steps\n        let proof = '';\n        while (tokens.length && (token = tokens[tokens.length - 1]) !== '$.') {\n            tokens.pop();\n            proof += token;\n            if (!containsonlyupperorq(token)) {\n                console.error('Bogus character found in compressed proof of ' + label);\n                return false;\n            }\n        }\n        if (!tokens.length) {\n            console.error('Unfinished $p statement ' + label);\n            return false;\n        }\n        if (!proof.length) {\n            console.error('Theorem ' + label + ' has no proof');\n            return false;\n        }\n        tokens.pop(); // Discard $. token\n        if (proof.includes('?')) {\n            console.error('Warning: Proof of theorem ' + label + ' is incomplete');\n            return true; // Continue processing file\n        }\n        const proofnumbers = getproofnumbers(label, proof);\n        if (!proofnumbers)\n            return false;\n        const okay = verifycompressedproof(label, assertion, labels, proofnumbers);\n        if (!okay)\n            return false;\n    }\n    else {\n        // Regular (uncompressed proof)\n        const proof = [];\n        let incomplete = false;\n        let token;\n        while (tokens.length && (token = tokens[tokens.length - 1]) !== '$.') {\n            tokens.pop();\n            proof.push(token);\n            if (token === '?')\n                incomplete = true;\n            else if (token === label) {\n                console.error('Proof of theorem ' + label + ' refers to itself');\n                return false;\n            }\n            else if (!assertions.has(token) && !isactivehyp(token)) {\n                console.error('Proof of theorem ' + label + ' refers to ' + token + ' which is not an active statement');\n                return false;\n            }\n        }\n        if (!tokens.length) {\n            console.error('Unfinished $p statement ' + label);\n            return false;\n        }\n        if (!proof.length) {\n            console.error('Theorem ' + label + ' has no proof');\n            return false;\n        }\n        tokens.pop(); // Discard $. token\n        if (incomplete) {\n            console.error('Warning: Proof of theorem ' + label + ' is incomplete');\n            return true; // Continue processing file\n        }\n        const okay = verifyregularproof(label, assertion, proof);\n        if (!okay)\n            return false;\n    }\n    return true;\n};\n// Parse $e statement. Return true iff okay.\nlet parsee = (label) => {\n    const newhyp = readexpression('e', label, '$.');\n    if (!newhyp) {\n        return false;\n    }\n    // Create new essential hypothesis\n    hypotheses.set(label, { first: newhyp, second: false });\n    scopes[scopes.length - 1].activehyp.push(label);\n    return true;\n};\n// Parse $a statement. Return true iff okay.\nlet parsea = (label) => {\n    const newaxiom = readexpression('a', label, '$.');\n    if (!newaxiom) {\n        return false;\n    }\n    constructassertion(label, newaxiom);\n    return true;\n};\n// Parse $f statement. Return true iff okay.\nlet parsef = (label) => {\n    if (!tokens.length) {\n        console.error('Unfinished $f statement' + label);\n        return false;\n    }\n    const typeToken = tokens[tokens.length - 1];\n    if (!constants.has(typeToken)) {\n        console.error('First symbol in $f statement ' + label + ' is ' + typeToken + ' which is not a constant');\n        return false;\n    }\n    tokens.pop();\n    if (!tokens.length) {\n        console.error('Unfinished $f statement ' + label);\n        return false;\n    }\n    const variable = tokens[tokens.length - 1];\n    if (!isactivevariable(variable)) {\n        console.error('Second symbol in $f statement ' + label + ' is ' + variable + ' which is not an active variable');\n        return false;\n    }\n    if (getfloatinghyp(variable).length) {\n        console.error('The variable ' + variable + ' appears in a second $f statement ' + label);\n        return false;\n    }\n    tokens.pop();\n    if (!tokens.length) {\n        console.error('Unfinished $f statement' + label);\n        return false;\n    }\n    if (tokens[tokens.length - 1] !== '$.') {\n        console.error('Expected end of $f statement ' + label + ' but found ' + tokens[tokens.length - 1]);\n        return false;\n    }\n    tokens.pop(); // Discard $. token\n    // Create new floating hypothesis\n    const newhyp = [];\n    newhyp.push(typeToken);\n    newhyp.push(variable);\n    hypotheses.set(label, { first: newhyp, second: true });\n    scopes[scopes.length - 1].activehyp.push(label);\n    scopes[scopes.length - 1].floatinghyp.set(variable, label);\n    return true;\n};\n// Parse labeled statement. Return true iff okay.\nlet parselabel = (label) => {\n    if (constants.has(label)) {\n        console.error('Attempt to reuse constant ' + label + ' as a label');\n        return false;\n    }\n    if (variables.has(label)) {\n        console.error('Attempt to reuse variable ' + label + ' as a label');\n        return false;\n    }\n    if (labelused(label)) {\n        console.error('Attempt to reuse label ' + label);\n        return false;\n    }\n    if (!tokens.length) {\n        console.error('Unfinished labeled statement');\n        return false;\n    }\n    const typeToken = tokens.pop();\n    let okay = true;\n    if (typeToken === '$p') {\n        okay = parsep(label);\n    }\n    else if (typeToken === '$e') {\n        okay = parsee(label);\n    }\n    else if (typeToken === '$a') {\n        okay = parsea(label);\n    }\n    else if (typeToken === '$f') {\n        okay = parsef(label);\n    }\n    else {\n        console.error('Unexpected token ' + typeToken + ' encountered');\n        return false;\n    }\n    return okay;\n};\n// Parse $d statement. Return true iff okay.\nlet parsed = () => {\n    const dvars = new Set();\n    let token;\n    while (tokens.length && (token = tokens[tokens.length - 1]) !== '$.') {\n        tokens.pop();\n        if (!isactivevariable(token)) {\n            console.error('Token ' + token + ' is not an active variable, ' + 'but was found in a $d statement');\n            return false;\n        }\n        if (dvars.has(token)) {\n            console.error('$d statement mentions ' + token + ' twice');\n            return false;\n        }\n        dvars.add(token);\n    }\n    if (!tokens.length) {\n        console.error('Unterminated $d statement');\n        return false;\n    }\n    if (dvars.size < 2) {\n        console.error('Not enough items in $d statement');\n        return false;\n    }\n    // Record it\n    scopes[scopes.length - 1].disjvars.push(dvars);\n    tokens.pop(); // Discard $. token\n    return true;\n};\n// Parse $c statement. Return true iff okay.\nlet parsec = () => {\n    if (scopes.length > 1) {\n        console.error('$c statement occurs in inner block');\n        return false;\n    }\n    let token;\n    let listempty = true;\n    while (tokens.length && (token = tokens[tokens.length - 1]) !== '$.') {\n        tokens.pop();\n        listempty = false;\n        if (!ismathsymboltoken(token)) {\n            console.error('Attempt to declare ' + token + ' as a constant');\n            return false;\n        }\n        if (variables.has(token)) {\n            console.error('Attempt to redeclare variable ' + token + ' as a constant');\n            return false;\n        }\n        if (labelused(token)) {\n            console.error('Attempt to reuse label ' + token + ' as a constant');\n            return false;\n        }\n        if (constants.has(token)) {\n            console.error('Attempt to redeclare constant ' + token);\n            return false;\n        }\n        constants.add(token);\n    }\n    if (!tokens.length) {\n        console.error('Unterminated $c statement');\n        return false;\n    }\n    if (listempty) {\n        console.error('Empty $c statement');\n        return false;\n    }\n    tokens.pop(); // Discard $. token\n    return true;\n};\n// Parse $v statement. Return true iff okay.\nlet parsev = () => {\n    let token;\n    let listempty = true;\n    while (tokens.length && (token = tokens[tokens.length - 1]) !== '$.') {\n        tokens.pop();\n        listempty = false;\n        if (!ismathsymboltoken(token)) {\n            console.error('Attempt to declare ' + token + ' as a variable');\n            return false;\n        }\n        if (constants.has(token)) {\n            console.error('Attempt to redeclare constant ' + token + ' as a variable');\n            return false;\n        }\n        if (labelused(token)) {\n            console.error('Attempt to reuse label ' + token + ' as a variable');\n            return false;\n        }\n        const alreadyactive = isactivevariable(token);\n        if (alreadyactive) {\n            console.error('Attempt to redeclare active variable ' + token);\n            return false;\n        }\n        variables.add(token);\n        scopes[scopes.length - 1].activevariables.add(token);\n    }\n    if (!tokens.length) {\n        console.error('Unterminated $v statement');\n        return false;\n    }\n    if (listempty) {\n        console.error('Empty $v statement');\n        return false;\n    }\n    tokens.pop(); // Discard $. token\n    return true;\n};\nconst EXIT_FAILURE = 1;\nlet main = (argv) => __awaiter(void 0, void 0, void 0, function* () {\n    if (argv.length !== 2) {\n        console.error('Syntax: checkmm <filename>');\n        return EXIT_FAILURE;\n    }\n    const okay = yield readtokens(argv[1]);\n    if (!okay)\n        return EXIT_FAILURE;\n    // Reverse the order of the tokens.  We do this O(n) operation just\n    // once here so that the tokens were added with 'push' O(1) but\n    // can be removed with 'pop' O(1) in the order they were added (first\n    // in first out).  It's completely impractical to use 'shift' or 'unshift'\n    // because they're O(n) operations.\n    tokens.reverse();\n    scopes.push(new Scope());\n    while (tokens.length) {\n        const token = tokens.pop();\n        let okay = true;\n        if (islabeltoken(token)) {\n            okay = parselabel(token);\n        }\n        else if (token === '$d') {\n            okay = parsed();\n        }\n        else if (token === '${') {\n            scopes.push(new Scope());\n        }\n        else if (token === '$}') {\n            scopes.pop();\n            if (!scopes.length) {\n                console.error('$} without corresponding ${');\n                return EXIT_FAILURE;\n            }\n        }\n        else if (token === '$c') {\n            okay = parsec();\n        }\n        else if (token === '$v') {\n            okay = parsev();\n        }\n        else {\n            console.error('Unexpected token ' + token + ' encountered');\n            return EXIT_FAILURE;\n        }\n        if (!okay)\n            return EXIT_FAILURE;\n    }\n    if (scopes.length > 1) {\n        console.error('${ without corresponding $}');\n        return EXIT_FAILURE;\n    }\n    return 0;\n});\n// Are we being run as a cli program or a library?\nif (process) {\n    const executedScript = process.argv.length >= 2 ? process.argv[1] : '';\n    const validCliSuffices = [__filename, '/.bin/checkmm', '/bin/checkmm', '/cli.js'];\n    const isCliCommand = validCliSuffices.reduce((acc, suffix) => (acc ? acc : executedScript.slice(-suffix.length) === suffix), false);\n    if (isCliCommand) {\n        // We are being run as a cli program\n        main(process.argv.slice(1)).then(exitCode => {\n            process.exitCode = exitCode;\n        });\n    }\n}\nexports.default = {\n    tokens,\n    setTokens: (_tokens) => {\n        tokens = _tokens;\n    },\n    constants,\n    setConstants: (_constants) => {\n        constants = _constants;\n    },\n    hypotheses,\n    setHypotheses: (_hypotheses) => {\n        hypotheses = _hypotheses;\n    },\n    variables,\n    setVariables: (_variables) => {\n        variables = _variables;\n    },\n    assertions,\n    setAssertions: (_assertions) => {\n        assertions = _assertions;\n    },\n    scopes,\n    setScopes: (_scopes) => {\n        scopes = _scopes;\n    },\n    labelused,\n    setLabelused: (_labelused) => {\n        labelused = _labelused;\n    },\n    getfloatinghyp,\n    setGetfloatinghyp: (_getfloatinghyp) => {\n        getfloatinghyp = _getfloatinghyp;\n    },\n    isactivevariable,\n    setIsactivevariable: (_isactivevariable) => {\n        isactivevariable = _isactivevariable;\n    },\n    isactivehyp,\n    setIsactivehyp: (_isactivehyp) => {\n        isactivehyp = _isactivehyp;\n    },\n    isdvr,\n    setIsdvr: (_isdvr) => {\n        isdvr = _isdvr;\n    },\n    ismmws,\n    setIsmmws: (_ismmws) => {\n        ismmws = _ismmws;\n    },\n    islabeltoken,\n    setIslabeltoken: (_islabeltoken) => {\n        islabeltoken = _islabeltoken;\n    },\n    ismathsymboltoken,\n    setIsmathsymboltoken: (_ismathsymboltoken) => {\n        ismathsymboltoken = _ismathsymboltoken;\n    },\n    containsonlyupperorq,\n    setContainsonlyupperorq: (_containsonlyupperorq) => {\n        containsonlyupperorq = _containsonlyupperorq;\n    },\n    nexttoken,\n    setNexttoken: (_nexttoken) => {\n        nexttoken = _nexttoken;\n    },\n    readtokens,\n    setReadtokens: (_readtokens) => {\n        readtokens = _readtokens;\n    },\n    constructassertion,\n    setConstructassertion: (_constructassertion) => {\n        constructassertion = _constructassertion;\n    },\n    readexpression,\n    setReadexpression: (_readexpression) => {\n        readexpression = _readexpression;\n    },\n    makesubstitution,\n    setMakesubstitution: (_makesubstitution) => {\n        makesubstitution = _makesubstitution;\n    },\n    getproofnumbers,\n    setGetproofnumbers: (_getproofnumbers) => {\n        getproofnumbers = _getproofnumbers;\n    },\n    verifyassertionref,\n    setVerifyassertionref: (_verifyassertionref) => {\n        verifyassertionref = _verifyassertionref;\n    },\n    verifyregularproof,\n    setVerifyrefularproof: (_verifyregularproof) => {\n        verifyregularproof = _verifyregularproof;\n    },\n    verifycompressedproof,\n    setVerifycompressedproof: (_verifycompressedproof) => {\n        verifycompressedproof = _verifycompressedproof;\n    },\n    parsep,\n    setParsep: (_parsep) => {\n        parsep = _parsep;\n    },\n    parsee,\n    setParsee: (_parsee) => {\n        parsee = _parsee;\n    },\n    parsea,\n    setParsea: (_parsea) => {\n        parsea = _parsea;\n    },\n    parsef,\n    setParsef: (_parsef) => {\n        parsef = _parsef;\n    },\n    parselabel,\n    setParselabel: (_parselabel) => {\n        parselabel = _parselabel;\n    },\n    parsed,\n    setParsed: (_parsed) => {\n        parsed = _parsed;\n    },\n    parsec,\n    setParsec: (_parsec) => {\n        parsec = _parsec;\n    },\n    parsev,\n    setParsev: (_parsev) => {\n        parsev = _parsev;\n    },\n    main,\n    setMain: (_main) => {\n        main = _main;\n    },\n};\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createStack = exports.arraysequal = exports.Deque = exports.Vector = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst util_1 = require(\"util\");\nconst readFile = (0, util_1.promisify)(fs_1.default.readFile);\n// checkmm uses a little bit of C++'s Standard Template Library.  Simulate it.\nlet isupper = (s) => {\n    if (/[^A-Z]/.test(s)) {\n        return false;\n    }\n    else {\n        return true;\n    }\n};\nlet isalnum = (s) => {\n    if (/[^a-zA-Z0-9]/.test(s)) {\n        return false;\n    }\n    else {\n        return true;\n    }\n};\nlet set_intersection = (s1, s2) => {\n    const s3 = new Set();\n    s1.forEach((value) => {\n        if (s2.has(value)) {\n            s3.add(value);\n        }\n    });\n    return s3;\n};\nclass Vector extends Array {\n}\nexports.Vector = Vector;\nclass Deque extends Array {\n}\nexports.Deque = Deque;\nlet stringstream = (str) => {\n    let index = 0;\n    const stream = {\n        get: () => {\n            const ch = str.charAt(index);\n            ++index;\n            return ch;\n        },\n        good: () => true,\n        unget: () => {\n            --index;\n        },\n        eof: () => index >= stringstream.length,\n        fail: () => false,\n    };\n    return stream;\n};\nlet ifstream = (filename) => __awaiter(void 0, void 0, void 0, function* () {\n    return stringstream(yield readFile(filename, { encoding: 'utf-8' }));\n});\n// Simple function for comparing arrays (in C++ STL handles this automatically)\nlet arraysequal = (arr1, arr2) => {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let n = 0; n < arr1.length; ++n) {\n        if (arr1[n] !== arr2[n]) {\n            return false;\n        }\n    }\n    return true;\n};\nexports.arraysequal = arraysequal;\nlet createStack = (arr) => {\n    let container = arr !== null && arr !== void 0 ? arr : [];\n    return {\n        push: (item) => {\n            container.push(item);\n        },\n        pop: () => container.pop(),\n        size: () => container.length,\n        top: () => container[container.length - 1],\n        truncate: (newLength) => {\n            container = container.slice(0, newLength);\n        },\n        at: (index) => container[index],\n        toArray: () => [...container],\n    };\n};\nexports.createStack = createStack;\nexports.default = {\n    isupper,\n    setIsupper: (_isupper) => {\n        isupper = _isupper;\n    },\n    isalnum,\n    setIsalum: (_isalum) => {\n        isalnum = _isalum;\n    },\n    set_intersection,\n    setSet_intersection: (_set_intersection) => {\n        set_intersection = _set_intersection;\n    },\n    stringstream,\n    setStringstream: (_stringstream) => {\n        stringstream = _stringstream;\n    },\n    ifstream,\n    setIfstream: (_ifstream) => {\n        ifstream = _ifstream;\n    },\n    arraysequal: exports.arraysequal,\n    setArraysequal: (_arraysequal) => {\n        exports.arraysequal = _arraysequal;\n    },\n    createStack: exports.createStack,\n    setCreateStack: (_createStack) => {\n        exports.createStack = _createStack;\n    },\n};\n","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(13);\n"],"names":["__createBinding","this","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","done","then","apply","__importDefault","exports","Scope","Assertion","path_1","std_1","tokens","constants","Set","hypotheses","Map","variables","constructor","disjvars","expression","assertions","activevariables","activehyp","floatinghyp","scopes","Array","labelused","label","getfloatinghyp","vari","scope","loc","isactivevariable","str","has","isactivehyp","find","_str","isdvr","var1","var2","disjvar","ismmws","ch","islabeltoken","token","default","isalnum","ismathsymboltoken","includes","containsonlyupperorq","isupper","nexttoken","input","good","unget","console","error","charCodeAt","toString","eof","fail","mmfilenames","readtokens","filename","instream","add","ifstream","_e","incomment","infileinclusion","newfilename","length","normalize","join","dirname","push","constructassertion","exp","assertion","set","varsused","slice","reverse","hypvec","item2","hyp","second","first","unshift","item3","dset","from","set_intersection","index","index2","readexpression","stattype","terminator","type","pop","makesubstitution","original","substmap","destination","item","getproofnumbers","proof","proofnumbers","num","justgotnum","addval","Number","MAX_SAFE_INTEGER","verifyassertionref","thlabel","reflabel","stack","size","base","substitutions","i","hypothesis","at","subst","dest","arraysequal","truncate","exp1","exp2","exp1vars","exp1item","exp2vars","exp2item","verifyregularproof","theorem","createStack","proofstep","verifycompressedproof","labels","mandhypt","labelt","savedsteps","top","parsep","newtheorem","_token","incomplete","parsee","newhyp","parsea","newaxiom","parsef","typeToken","variable","parselabel","okay","parsed","dvars","parsec","listempty","parsev","main","argv","process","executedScript","__filename","reduce","acc","suffix","exitCode","setTokens","_tokens","setConstants","_constants","setHypotheses","_hypotheses","setVariables","_variables","setAssertions","_assertions","setScopes","_scopes","setLabelused","_labelused","setGetfloatinghyp","_getfloatinghyp","setIsactivevariable","_isactivevariable","setIsactivehyp","_isactivehyp","setIsdvr","_isdvr","setIsmmws","_ismmws","setIslabeltoken","_islabeltoken","setIsmathsymboltoken","_ismathsymboltoken","setContainsonlyupperorq","_containsonlyupperorq","setNexttoken","_nexttoken","setReadtokens","_readtokens","setConstructassertion","_constructassertion","setReadexpression","_readexpression","setMakesubstitution","_makesubstitution","setGetproofnumbers","_getproofnumbers","setVerifyassertionref","_verifyassertionref","setVerifyrefularproof","_verifyregularproof","setVerifycompressedproof","_verifycompressedproof","setParsep","_parsep","setParsee","_parsee","setParsea","_parsea","setParsef","_parsef","setParselabel","_parselabel","setParsed","_parsed","setParsec","_parsec","setParsev","_parsev","setMain","_main","Deque","Vector","fs_1","readFile","promisify","s","test","s1","s2","s3","forEach","stringstream","charAt","encoding","arr1","arr2","n","arr","container","newLength","toArray","setIsupper","_isupper","setIsalum","_isalum","setSet_intersection","_set_intersection","setStringstream","_stringstream","setIfstream","_ifstream","setArraysequal","_arraysequal","setCreateStack","_createStack","module","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}