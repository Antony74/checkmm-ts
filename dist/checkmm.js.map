{"version":3,"file":"checkmm.js","mappings":"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","sources":["webpack://checkmm/./src/checkmm.ts","webpack://checkmm/./src/std.ts","webpack://checkmm/./src/tokens.ts","webpack://checkmm/external node-commonjs \"fs\"","webpack://checkmm/external node-commonjs \"fs/promises\"","webpack://checkmm/external node-commonjs \"path\"","webpack://checkmm/external node-commonjs \"util\"","webpack://checkmm/webpack/bootstrap","webpack://checkmm/webpack/startup"],"sourcesContent":["\"use strict\";\n// Metamath database verifier\n// Antony Bartlett (akb@akb.me.uk)\n//\n// I release this code to the public domain under the\n// Creative Commons \"CC0 1.0 Universal\" Public Domain Dedication:\n//\n// http://creativecommons.org/publicdomain/zero/1.0/\n//\n// This is a port to TypeScript.  The original C++ program was\n// written by Eric Schmidt and can be found here:\n// http://us.metamath.org/other.html#checkmm\n//\n// This is a standalone verifier for Metamath database files.\n// Run it with a single file name as the parameter.\n//\n// Some notes:\n//\n// The code assumes that the character set is compatible with ASCII.\n//\n// According to the spec, file inclusion commands should not include a file\n// that has already been included. Unfortunately, determing whether two\n// different strings refer to the same file is not easy, and, worse, is\n// system-dependant. This program ignores the issue entirely and assumes\n// that distinct strings name different files. This should be adequate for\n// the present, at least.\n//\n// If the verifier finds an error, it will report it and quit. It will not\n// attempt to recover and find more errors. The only condition that generates\n// a diagnostic message but doesn't halt the program is an incomplete proof,\n// specified by a question mark. In that case, as per the spec, a warning is\n// issued and checking continues.\n//\n// Please let me know of any bugs.\n// https://github.com/Antony74/checkmm-ts/issues\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Scope = exports.Assertion = void 0;\nconst promises_1 = __importDefault(require(\"fs/promises\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst std_1 = __importDefault(require(\"./std\"));\nconst tokens_1 = require(\"./tokens\");\nlet std = std_1.default;\nlet createTokenArray = tokens_1.createTokenArray;\nlet data = '';\nlet dataPosition = 0;\nlet tokens = createTokenArray();\nlet constants = new Set();\nlet hypotheses = new Map();\nlet variables = new Set();\n// An axiom or a theorem.\nclass Assertion {\n    constructor() {\n        // Hypotheses of this axiom or theorem.\n        this.hypotheses = [];\n        this.disjvars = new Set();\n        // Statement of axiom or theorem.\n        this.expression = [];\n    }\n}\nexports.Assertion = Assertion;\nlet assertions = new Map();\nclass Scope {\n    constructor() {\n        this.activevariables = new Set();\n        // Labels of active hypotheses\n        this.activehyp = [];\n        this.disjvars = [];\n        // Map from variable to label of active floating hypothesis\n        this.floatinghyp = new Map();\n    }\n}\nexports.Scope = Scope;\nlet scopes = new Array();\n// Determine if a string is used as a label\nlet labelused = (label) => {\n    return hypotheses.get(label) !== undefined || assertions.get(label) !== undefined;\n};\n// Find active floating hypothesis corresponding to variable, or empty string\n// if there isn't one.\nlet getfloatinghyp = (vari) => {\n    for (const scope of scopes) {\n        const loc = scope.floatinghyp.get(vari);\n        if (loc !== undefined)\n            return loc;\n    }\n    return '';\n};\n// Determine if a string is an active variable.\nlet isactivevariable = (str) => {\n    for (const scope of scopes) {\n        if (scope.activevariables.has(str))\n            return true;\n    }\n    return false;\n};\n// Determine if a string is the label of an active hypothesis.\nlet isactivehyp = (str) => {\n    for (const scope of scopes) {\n        if (scope.activehyp.find(_str => str === _str))\n            return true;\n    }\n    return false;\n};\n// Determine if there is an active disjoint variable restriction on\n// two different variables.\nlet isdvr = (var1, var2) => {\n    if (var1 === var2)\n        return false;\n    for (const scope of scopes) {\n        for (const disjvar of scope.disjvars) {\n            if (disjvar.has(var1) && disjvar.has(var2))\n                return true;\n        }\n    }\n    return false;\n};\n// Determine if a character is white space in Metamath.\nlet ismmws = (ch) => {\n    // This doesn't include \\v (\"vertical tab\"), as the spec omits it.\n    return ch === ' ' || ch === '\\n' || ch === '\\t' || ch === '\\f' || ch === '\\r';\n};\n// Determine if a token is a label token.\nlet islabeltoken = (token) => {\n    for (const ch of token) {\n        if (!(std.isalnum(ch) || ch === '.' || ch === '-' || ch === '_'))\n            return false;\n    }\n    return true;\n};\n// Determine if a token is a math symbol token.\nlet ismathsymboltoken = (token) => {\n    return !token.includes('$');\n};\n// Determine if a token consists solely of upper-case letters or question marks\nlet containsonlyupperorq = (token) => {\n    for (const ch of token) {\n        if (!std.isupper(ch) && ch !== '?')\n            return false;\n    }\n    return true;\n};\nlet nexttoken = () => {\n    let ch;\n    let token = '';\n    // Skip whitespace\n    while (!!(ch = data.charAt(dataPosition)) && ismmws(ch)) {\n        ++dataPosition;\n    }\n    // Get token\n    while (!!(ch = data.charAt(dataPosition)) && !ismmws(ch)) {\n        if (ch < '!' || ch > '~') {\n            throw new Error('Invalid character read with code 0x' + ch.charCodeAt(0).toString(16));\n        }\n        token += ch;\n        ++dataPosition;\n    }\n    return token;\n};\nlet readFile = (filename) => __awaiter(void 0, void 0, void 0, function* () { return promises_1.default.readFile(filename, { encoding: 'utf-8' }); });\nlet mmfilenamesalreadyencountered = new Set();\nlet readtokens = (filename, lastInFileInclusionStart = 0) => __awaiter(void 0, void 0, void 0, function* () {\n    const alreadyencountered = mmfilenamesalreadyencountered.has(filename);\n    if (alreadyencountered)\n        return;\n    mmfilenamesalreadyencountered.add(filename);\n    try {\n        data = data.slice(0, lastInFileInclusionStart) + (yield readFile(filename)) + data.slice(dataPosition);\n        dataPosition = lastInFileInclusionStart;\n    }\n    catch (_e) {\n        throw new Error('Could not open ' + filename);\n    }\n    let incomment = false;\n    let infileinclusion = false;\n    let newfilename = '';\n    let token;\n    while ((token = nexttoken()).length) {\n        if (incomment) {\n            if (token === '$)') {\n                incomment = false;\n                continue;\n            }\n            if (token.includes('$(')) {\n                throw new Error('Characters $( found in a comment');\n            }\n            if (token.includes('$)')) {\n                throw new Error('Characters $) found in a comment');\n            }\n            continue;\n        }\n        // Not in comment\n        if (token === '$(') {\n            incomment = true;\n            continue;\n        }\n        if (infileinclusion) {\n            if (!newfilename.length) {\n                if (token.includes('$')) {\n                    throw new Error('Filename ' + token + ' contains a $');\n                }\n                if (path_1.default) {\n                    newfilename = path_1.default.normalize(path_1.default.join(path_1.default.dirname(filename), token));\n                }\n                else {\n                    newfilename = token;\n                }\n                continue;\n            }\n            else {\n                if (token !== '$]') {\n                    throw new Error(\"Didn't find closing file inclusion delimiter\");\n                }\n                yield readtokens(newfilename, lastInFileInclusionStart);\n                infileinclusion = false;\n                newfilename = '';\n                continue;\n            }\n        }\n        if (token === '$[') {\n            infileinclusion = true;\n            lastInFileInclusionStart = dataPosition - 2;\n            continue;\n        }\n        tokens.push(token);\n    }\n    if (incomment) {\n        throw new Error('Unclosed comment');\n    }\n    if (infileinclusion) {\n        throw new Error('Unfinished file inclusion command');\n    }\n});\n// Construct an Assertion from an Expression. That is, determine the\n// mandatory hypotheses and disjoint variable restrictions.\n// The Assertion is inserted into the assertions collection,\n// and is returned by reference.\nlet constructassertion = (label, exp) => {\n    const assertion = new Assertion();\n    assertions.set(label, assertion);\n    assertion.expression = exp;\n    const varsused = new Set();\n    // Determine variables used and find mandatory hypotheses\n    for (const e of exp) {\n        if (variables.has(e))\n            varsused.add(e);\n    }\n    for (const scope of scopes.slice().reverse()) {\n        const hypvec = scope.activehyp;\n        for (const item2 of hypvec.slice().reverse()) {\n            const hyp = hypotheses.get(item2);\n            if (hyp.second && varsused.has(hyp.first[1])) {\n                // Mandatory floating hypothesis\n                assertion.hypotheses.unshift(item2);\n            }\n            else if (!hyp.second) {\n                // Essential hypothesis\n                assertion.hypotheses.unshift(item2);\n                for (const item3 of hyp.first) {\n                    if (variables.has(item3))\n                        varsused.add(item3);\n                }\n            }\n        }\n    }\n    // Determine mandatory disjoint variable restrictions\n    for (const scope of scopes) {\n        const disjvars = scope.disjvars;\n        for (const item2 of disjvars) {\n            const dset = Array.from(std.set_intersection(item2, varsused));\n            for (let index = 0; index < dset.length; ++index) {\n                for (let index2 = index + 1; index2 < dset.length; ++index2) {\n                    assertion.disjvars.add({ first: dset[index], second: dset[index2] });\n                }\n            }\n        }\n    }\n    return assertion;\n};\n// Read an expression from the token stream. Returns true iff okay.\nlet readexpression = (stattype, label, terminator) => {\n    if (tokens.empty()) {\n        throw new Error('Unfinished $' + stattype + ' statement ' + label);\n    }\n    const type = tokens.front();\n    if (!constants.has(type)) {\n        throw new Error('First symbol in $' + stattype + ' statement ' + label + ' is ' + type + ' which is not a constant');\n    }\n    tokens.pop();\n    const exp = [type];\n    let token;\n    while (!tokens.empty() && (token = tokens.front()) !== terminator) {\n        tokens.pop();\n        if (!constants.has(token) && !getfloatinghyp(token).length) {\n            throw new Error('In $' +\n                stattype +\n                ' statement ' +\n                label +\n                ' token ' +\n                token +\n                ' found which is not a constant or variable in an' +\n                ' active $f statement');\n        }\n        exp.push(token);\n    }\n    if (tokens.empty()) {\n        throw new Error('Unfinished $' + stattype + ' statement ' + label);\n    }\n    tokens.pop(); // Discard terminator token\n    return exp;\n};\n// Make a substitution of variables. The result is put in \"destination\",\n// which should be empty.\nlet makesubstitution = (original, substmap) => {\n    let destination = [];\n    for (const item of original) {\n        const item2 = substmap.get(item);\n        if (!item2) {\n            // Constant\n            destination.push(item);\n        }\n        else {\n            // Variable\n            destination = [...destination, ...item2];\n        }\n    }\n    return destination;\n};\n// Get the raw numbers from compressed proof format.\n// The letter Z is translated as 0.\nlet getproofnumbers = (label, proof) => {\n    const proofnumbers = [];\n    let num = 0;\n    let justgotnum = false;\n    for (const item of proof) {\n        if (item <= 'T') {\n            const addval = item.charCodeAt(0) - ('A'.charCodeAt(0) - 1);\n            if (num > Number.MAX_SAFE_INTEGER / 20 || 20 * num > Number.MAX_SAFE_INTEGER - addval) {\n                throw new Error('Overflow computing numbers in compressed proof of ' + label);\n            }\n            proofnumbers.push(20 * num + addval);\n            num = 0;\n            justgotnum = true;\n        }\n        else if (item <= 'Y') {\n            const addval = item.charCodeAt(0) - 'T'.charCodeAt(0);\n            if (num > Number.MAX_SAFE_INTEGER / 5 || 5 * num > Number.MAX_SAFE_INTEGER - addval) {\n                throw new Error('Overflow computing numbers in compressed proof of ' + label);\n            }\n            num = 5 * num + addval;\n            justgotnum = false;\n        } // It must be Z\n        else {\n            if (!justgotnum) {\n                throw new Error('Stray Z found in compressed proof of ' + label);\n            }\n            proofnumbers.push(0);\n            justgotnum = false;\n        }\n    }\n    if (num !== 0) {\n        throw new Error('Compressed proof of theorem ' + label + ' ends in unfinished number');\n    }\n    return proofnumbers;\n};\n// Subroutine for proof verification. Verify a proof step referencing an\n// assertion (i.e., not a hypothesis).\nlet verifyassertionref = (thlabel, reflabel, stack) => {\n    const assertion = assertions.get(reflabel);\n    if (stack.size() < assertion.hypotheses.length) {\n        throw new Error('In proof of theorem ' + thlabel + ' not enough items found on stack');\n    }\n    const base = stack.size() - assertion.hypotheses.length;\n    const substitutions = new Map();\n    // Determine substitutions and check that we can unify\n    for (let i = 0; i < assertion.hypotheses.length; ++i) {\n        const hypothesis = hypotheses.get(assertion.hypotheses[i]);\n        if (hypothesis.second) {\n            // Floating hypothesis of the referenced assertion\n            if (hypothesis.first[0] !== stack.at(base + i)[0]) {\n                throw new Error('In proof of theorem ' + thlabel + ' unification failed');\n            }\n            const subst = stack.at(base + i).slice(1);\n            substitutions.set(hypothesis.first[1], subst);\n        }\n        else {\n            // Essential hypothesis\n            const dest = makesubstitution(hypothesis.first, substitutions);\n            if (!std.arraysequal(dest, stack.at(base + i))) {\n                throw new Error('In proof of theorem ' + thlabel + ' unification failed');\n            }\n        }\n    }\n    // Remove hypotheses from stack\n    stack.truncate(base);\n    // Verify disjoint variable conditions\n    for (const item of assertion.disjvars) {\n        const exp1 = substitutions.get(item.first);\n        const exp2 = substitutions.get(item.second);\n        const exp1vars = new Set();\n        for (const exp1item of exp1) {\n            if (variables.has(exp1item))\n                exp1vars.add(exp1item);\n        }\n        const exp2vars = new Set();\n        for (const exp2item of exp2) {\n            if (variables.has(exp2item))\n                exp2vars.add(exp2item);\n        }\n        for (const exp1item of exp1vars) {\n            for (const exp2item of exp2vars) {\n                if (!isdvr(exp1item, exp2item)) {\n                    throw new Error('In proof of theorem ' + thlabel + ' disjoint variable restriction violated');\n                }\n            }\n        }\n    }\n    // Done verification of this step. Insert new statement onto stack.\n    const dest = makesubstitution(assertion.expression, substitutions);\n    stack.push(dest);\n    return stack;\n};\n// Verify a regular proof. The \"proof\" argument should be a non-empty sequence\n// of valid labels. Return true iff the proof is correct.\nlet verifyregularproof = (label, theorem, proof) => {\n    let stack = std.createstack();\n    for (const proofstep of proof) {\n        // If step is a hypothesis, just push it onto the stack.\n        const hyp = hypotheses.get(proofstep);\n        if (hyp) {\n            stack.push(hyp.first);\n            continue;\n        }\n        // It must be an axiom or theorem\n        stack = verifyassertionref(label, proofstep, stack);\n    }\n    if (stack.size() !== 1) {\n        throw new Error('Proof of theorem ' + label + ' does not end with only one item on the stack');\n    }\n    if (!std.arraysequal(stack.at(0), theorem.expression)) {\n        throw new Error('Proof of theorem ' + label + ' proves wrong statement');\n    }\n};\n// Verify a compressed proof\nlet verifycompressedproof = (label, theorem, labels, proofnumbers) => {\n    let stack = std.createstack();\n    const mandhypt = theorem.hypotheses.length;\n    const labelt = mandhypt + labels.length;\n    const savedsteps = [];\n    for (const item of proofnumbers) {\n        // Save the last proof step if 0\n        if (item === 0) {\n            savedsteps.push(stack.top());\n            continue;\n        }\n        // If step is a mandatory hypothesis, just push it onto the stack.\n        if (item <= mandhypt) {\n            stack.push(hypotheses.get(theorem.hypotheses[item - 1]).first);\n        }\n        else if (item <= labelt) {\n            const proofstep = labels[item - mandhypt - 1];\n            // If step is a (non-mandatory) hypothesis,\n            // just push it onto the stack.\n            const hyp = hypotheses.get(proofstep);\n            if (hyp) {\n                stack.push(hyp.first);\n                continue;\n            }\n            // It must be an axiom or theorem\n            stack = verifyassertionref(label, proofstep, stack);\n        } // Must refer to saved step\n        else {\n            if (item > labelt + savedsteps.length) {\n                throw new Error('Number in compressed proof of ' + label + ' is too high');\n            }\n            stack.push(savedsteps[item - labelt - 1]);\n        }\n    }\n    if (stack.size() !== 1) {\n        throw new Error('Proof of theorem ' + label + ' does not end with only one item on the stack');\n    }\n    if (!std.arraysequal(stack.at(0), theorem.expression)) {\n        throw new Error('Proof of theorem ' + label + ' proves wrong statement');\n    }\n};\n// Parse $p statement. Return true iff okay.\nlet parsep = (label) => {\n    const newtheorem = readexpression('p', label, '$=');\n    const assertion = constructassertion(label, newtheorem);\n    // Now for the proof\n    if (tokens.empty()) {\n        throw new Error('Unfinished $p statement ' + label);\n    }\n    if (tokens.front() === '(') {\n        // Compressed proof\n        tokens.pop();\n        // Get labels\n        const labels = [];\n        let token;\n        while (!tokens.empty() && (token = tokens.front()) !== ')') {\n            tokens.pop();\n            labels.push(token);\n            if (token === label) {\n                throw new Error('Proof of theorem ' + label + ' refers to itself');\n            }\n            else if (assertion.hypotheses.find(_token => _token === token)) {\n                throw new Error('Compressed proof of theorem ' + label + ' has mandatory hypothesis ' + token + ' in label list');\n            }\n            else if (!assertions.has(token) && !isactivehyp(token)) {\n                throw new Error('Proof of theorem ' + label + ' refers to ' + token + ' which is not an active statement');\n            }\n        }\n        if (tokens.empty()) {\n            throw new Error('Unfinished $p statement ' + label);\n        }\n        tokens.pop(); // Discard ) token\n        // Get proof steps\n        let proof = '';\n        while (!tokens.empty() && (token = tokens.front()) !== '$.') {\n            tokens.pop();\n            proof += token;\n            if (!containsonlyupperorq(token)) {\n                throw new Error('Bogus character found in compressed proof of ' + label);\n            }\n        }\n        if (tokens.empty()) {\n            throw new Error('Unfinished $p statement ' + label);\n        }\n        if (!proof.length) {\n            throw new Error('Theorem ' + label + ' has no proof');\n        }\n        tokens.pop(); // Discard $. token\n        if (proof.includes('?')) {\n            console.error('Warning: Proof of theorem ' + label + ' is incomplete');\n            return; // Continue processing file\n        }\n        const proofnumbers = getproofnumbers(label, proof);\n        verifycompressedproof(label, assertion, labels, proofnumbers);\n    }\n    else {\n        // Regular (uncompressed proof)\n        const proof = [];\n        let incomplete = false;\n        let token;\n        while (!tokens.empty() && (token = tokens.front()) !== '$.') {\n            tokens.pop();\n            proof.push(token);\n            if (token === '?')\n                incomplete = true;\n            else if (token === label) {\n                throw new Error('Proof of theorem ' + label + ' refers to itself');\n            }\n            else if (!assertions.has(token) && !isactivehyp(token)) {\n                throw new Error('Proof of theorem ' + label + ' refers to ' + token + ' which is not an active statement');\n            }\n        }\n        if (tokens.empty()) {\n            throw new Error('Unfinished $p statement ' + label);\n        }\n        if (!proof.length) {\n            throw new Error('Theorem ' + label + ' has no proof');\n        }\n        tokens.pop(); // Discard $. token\n        if (incomplete) {\n            throw new Error('Warning: Proof of theorem ' + label + ' is incomplete');\n        }\n        verifyregularproof(label, assertion, proof);\n    }\n};\n// Parse $e statement. Return true iff okay.\nlet parsee = (label) => {\n    const newhyp = readexpression('e', label, '$.');\n    // Create new essential hypothesis\n    hypotheses.set(label, { first: newhyp, second: false });\n    scopes[scopes.length - 1].activehyp.push(label);\n};\n// Parse $a statement. Return true iff okay.\nlet parsea = (label) => {\n    const newaxiom = readexpression('a', label, '$.');\n    constructassertion(label, newaxiom);\n};\n// Parse $f statement. Return true iff okay.\nlet parsef = (label) => {\n    if (tokens.empty()) {\n        throw new Error('Unfinished $f statement' + label);\n    }\n    const typeToken = tokens.front();\n    if (!constants.has(typeToken)) {\n        throw new Error('First symbol in $f statement ' + label + ' is ' + typeToken + ' which is not a constant');\n    }\n    tokens.pop();\n    if (tokens.empty()) {\n        throw new Error('Unfinished $f statement ' + label);\n    }\n    const variable = tokens.front();\n    if (!isactivevariable(variable)) {\n        throw new Error('Second symbol in $f statement ' + label + ' is ' + variable + ' which is not an active variable');\n    }\n    if (getfloatinghyp(variable).length) {\n        throw new Error('The variable ' + variable + ' appears in a second $f statement ' + label);\n    }\n    tokens.pop();\n    if (tokens.empty()) {\n        throw new Error('Unfinished $f statement' + label);\n    }\n    if (tokens.front() !== '$.') {\n        throw new Error('Expected end of $f statement ' + label + ' but found ' + tokens.front());\n    }\n    tokens.pop(); // Discard $. token\n    // Create new floating hypothesis\n    const newhyp = [];\n    newhyp.push(typeToken);\n    newhyp.push(variable);\n    hypotheses.set(label, { first: newhyp, second: true });\n    scopes[scopes.length - 1].activehyp.push(label);\n    scopes[scopes.length - 1].floatinghyp.set(variable, label);\n};\n// Parse labeled statement. Return true iff okay.\nlet parselabel = (label) => {\n    if (constants.has(label)) {\n        throw new Error('Attempt to reuse constant ' + label + ' as a label');\n    }\n    if (variables.has(label)) {\n        throw new Error('Attempt to reuse variable ' + label + ' as a label');\n    }\n    if (labelused(label)) {\n        throw new Error('Attempt to reuse label ' + label);\n    }\n    if (tokens.empty()) {\n        throw new Error('Unfinished labeled statement');\n    }\n    const typeToken = tokens.pop();\n    if (typeToken === '$p') {\n        parsep(label);\n    }\n    else if (typeToken === '$e') {\n        parsee(label);\n    }\n    else if (typeToken === '$a') {\n        parsea(label);\n    }\n    else if (typeToken === '$f') {\n        parsef(label);\n    }\n    else {\n        throw new Error('Unexpected token ' + typeToken + ' encountered');\n    }\n};\n// Parse $d statement. Return true iff okay.\nlet parsed = () => {\n    const dvars = new Set();\n    let token;\n    while (!tokens.empty() && (token = tokens.front()) !== '$.') {\n        tokens.pop();\n        if (!isactivevariable(token)) {\n            throw new Error('Token ' + token + ' is not an active variable, ' + 'but was found in a $d statement');\n        }\n        if (dvars.has(token)) {\n            throw new Error('$d statement mentions ' + token + ' twice');\n        }\n        dvars.add(token);\n    }\n    if (tokens.empty()) {\n        throw new Error('Unterminated $d statement');\n    }\n    if (dvars.size < 2) {\n        throw new Error('Not enough items in $d statement');\n    }\n    // Record it\n    scopes[scopes.length - 1].disjvars.push(dvars);\n    tokens.pop(); // Discard $. token\n};\n// Parse $c statement. Return true iff okay.\nlet parsec = () => {\n    if (scopes.length > 1) {\n        throw new Error('$c statement occurs in inner block');\n    }\n    let token;\n    let listempty = true;\n    while (!tokens.empty() && (token = tokens.front()) !== '$.') {\n        tokens.pop();\n        listempty = false;\n        if (!ismathsymboltoken(token)) {\n            throw new Error('Attempt to declare ' + token + ' as a constant');\n        }\n        if (variables.has(token)) {\n            throw new Error('Attempt to redeclare variable ' + token + ' as a constant');\n        }\n        if (labelused(token)) {\n            throw new Error('Attempt to reuse label ' + token + ' as a constant');\n        }\n        if (constants.has(token)) {\n            throw new Error('Attempt to redeclare constant ' + token);\n        }\n        constants.add(token);\n    }\n    if (tokens.empty()) {\n        throw new Error('Unterminated $c statement');\n    }\n    if (listempty) {\n        throw new Error('Empty $c statement');\n    }\n    tokens.pop(); // Discard $. token\n};\n// Parse $v statement. Return true iff okay.\nlet parsev = () => {\n    let token;\n    let listempty = true;\n    while (!tokens.empty() && (token = tokens.front()) !== '$.') {\n        tokens.pop();\n        listempty = false;\n        if (!ismathsymboltoken(token)) {\n            throw new Error('Attempt to declare ' + token + ' as a variable');\n        }\n        if (constants.has(token)) {\n            throw new Error('Attempt to redeclare constant ' + token + ' as a variable');\n        }\n        if (labelused(token)) {\n            throw new Error('Attempt to reuse label ' + token + ' as a variable');\n        }\n        const alreadyactive = isactivevariable(token);\n        if (alreadyactive) {\n            throw new Error('Attempt to redeclare active variable ' + token);\n        }\n        variables.add(token);\n        scopes[scopes.length - 1].activevariables.add(token);\n    }\n    if (tokens.empty()) {\n        throw new Error('Unterminated $v statement');\n    }\n    if (listempty) {\n        throw new Error('Empty $v statement');\n    }\n    tokens.pop(); // Discard $. token\n};\nconst EXIT_FAILURE = 1;\nlet main = (argv) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        if (argv.length !== 2) {\n            console.error('Syntax: checkmm <filename>');\n            return EXIT_FAILURE;\n        }\n        yield readtokens(argv[1]);\n        // Reverse the order of the tokens.  We do this O(n) operation just\n        // once here so that the tokens were added with 'push' O(1) but\n        // can be removed with 'pop' O(1) in the order they were added (first\n        // in first out).  It's completely impractical to use 'shift' or 'unshift'\n        // because they're O(n) operations.\n        tokens.reverse();\n        scopes.push(new Scope());\n        while (!tokens.empty()) {\n            const token = tokens.pop();\n            if (islabeltoken(token)) {\n                parselabel(token);\n            }\n            else if (token === '$d') {\n                parsed();\n            }\n            else if (token === '${') {\n                scopes.push(new Scope());\n            }\n            else if (token === '$}') {\n                scopes.pop();\n                if (!scopes.length) {\n                    throw new Error('$} without corresponding ${');\n                }\n            }\n            else if (token === '$c') {\n                parsec();\n            }\n            else if (token === '$v') {\n                parsev();\n            }\n            else {\n                throw new Error('Unexpected token ' + token + ' encountered');\n            }\n        }\n        if (scopes.length > 1) {\n            throw new Error('${ without corresponding $}');\n        }\n        return 0;\n    }\n    catch (err) {\n        if (err instanceof Error) {\n            console.error(err.message);\n        }\n        else {\n            console.error(err);\n        }\n        return EXIT_FAILURE;\n    }\n});\n// Are we being run as a cli program or a library?\nif (process) {\n    const executedScript = process.argv.length >= 2 ? process.argv[1] : '';\n    const validCliSuffices = [\n        __filename,\n        '/.bin/checkmm',\n        '/bin/checkmm',\n        '/cli.js',\n        '\\\\.bin\\\\checkmm',\n        '\\\\bin\\\\checkmm',\n        '\\\\cli.js',\n    ];\n    const isCliCommand = validCliSuffices.reduce((acc, suffix) => (acc ? acc : executedScript.slice(-suffix.length) === suffix), false);\n    if (isCliCommand) {\n        // We are being run as a cli program\n        main(process.argv.slice(1)).then(exitCode => {\n            process.exitCode = exitCode;\n        });\n    }\n}\nexports.default = {\n    get data() {\n        return data;\n    },\n    set data(_data) {\n        data = _data;\n    },\n    get dataPosition() {\n        return dataPosition;\n    },\n    set dataPosition(_dataPosition) {\n        dataPosition = _dataPosition;\n    },\n    get readFile() {\n        return readFile;\n    },\n    set readFile(_readFile) {\n        readFile = _readFile;\n    },\n    get std() {\n        return std;\n    },\n    set std(_std) {\n        std = _std;\n    },\n    get createTokenArray() {\n        return createTokenArray;\n    },\n    set createTokenArray(_createTokenArray) {\n        createTokenArray = _createTokenArray;\n    },\n    get tokens() {\n        return tokens;\n    },\n    set tokens(_tokens) {\n        tokens = _tokens;\n    },\n    get constants() {\n        return constants;\n    },\n    set constants(_constants) {\n        constants = _constants;\n    },\n    get hypotheses() {\n        return hypotheses;\n    },\n    set hypotheses(_hypotheses) {\n        hypotheses = _hypotheses;\n    },\n    get variables() {\n        return variables;\n    },\n    set variables(_variables) {\n        variables = _variables;\n    },\n    get assertions() {\n        return assertions;\n    },\n    set assertions(_assertions) {\n        assertions = _assertions;\n    },\n    get scopes() {\n        return scopes;\n    },\n    set scopes(_scopes) {\n        scopes = _scopes;\n    },\n    get labelused() {\n        return labelused;\n    },\n    set labelused(_labelused) {\n        labelused = _labelused;\n    },\n    get getfloatinghyp() {\n        return getfloatinghyp;\n    },\n    set getfloatinghyp(_getfloatinghyp) {\n        getfloatinghyp = _getfloatinghyp;\n    },\n    get isactivevariable() {\n        return isactivevariable;\n    },\n    set isactivevariable(_isactivevariable) {\n        isactivevariable = _isactivevariable;\n    },\n    get isactivehyp() {\n        return isactivehyp;\n    },\n    set isactivehyp(_isactivehyp) {\n        isactivehyp = _isactivehyp;\n    },\n    get isdvr() {\n        return isdvr;\n    },\n    set isdvr(_isdvr) {\n        isdvr = _isdvr;\n    },\n    get ismmws() {\n        return ismmws;\n    },\n    set ismmws(_ismmws) {\n        ismmws = _ismmws;\n    },\n    get islabeltoken() {\n        return islabeltoken;\n    },\n    set islabeltoken(_islabeltoken) {\n        islabeltoken = _islabeltoken;\n    },\n    get ismathsymboltoken() {\n        return ismathsymboltoken;\n    },\n    set ismathsymboltoken(_ismathsymboltoken) {\n        ismathsymboltoken = _ismathsymboltoken;\n    },\n    get containsonlyupperorq() {\n        return containsonlyupperorq;\n    },\n    set containsonlyupperorq(_containsonlyupperorq) {\n        containsonlyupperorq = _containsonlyupperorq;\n    },\n    get nexttoken() {\n        return nexttoken;\n    },\n    set nexttoken(_nexttoken) {\n        nexttoken = _nexttoken;\n    },\n    get mmfilenamesalreadyencountered() {\n        return mmfilenamesalreadyencountered;\n    },\n    set mmfilenamesalreadyencountered(_mmfilenamesalreadyencountered) {\n        mmfilenamesalreadyencountered = _mmfilenamesalreadyencountered;\n    },\n    get readtokens() {\n        return readtokens;\n    },\n    set readtokens(_readtokens) {\n        readtokens = _readtokens;\n    },\n    get constructassertion() {\n        return constructassertion;\n    },\n    set constructassertion(_constructassertion) {\n        constructassertion = _constructassertion;\n    },\n    get readexpression() {\n        return readexpression;\n    },\n    set readexpression(_readexpression) {\n        readexpression = _readexpression;\n    },\n    get makesubstitution() {\n        return makesubstitution;\n    },\n    set makesubstitution(_makesubstitution) {\n        makesubstitution = _makesubstitution;\n    },\n    get getproofnumbers() {\n        return getproofnumbers;\n    },\n    set getproofnumbers(_getproofnumbers) {\n        getproofnumbers = _getproofnumbers;\n    },\n    get verifyassertionref() {\n        return verifyassertionref;\n    },\n    set verifyassertionref(_verifyassertionref) {\n        verifyassertionref = _verifyassertionref;\n    },\n    get verifyregularproof() {\n        return verifyregularproof;\n    },\n    set verifyregularproof(_verifyregularproof) {\n        verifyregularproof = _verifyregularproof;\n    },\n    get verifycompressedproof() {\n        return verifycompressedproof;\n    },\n    set verifycompressedproof(_verifycompressedproof) {\n        verifycompressedproof = _verifycompressedproof;\n    },\n    get parsep() {\n        return parsep;\n    },\n    set parsep(_parsep) {\n        parsep = _parsep;\n    },\n    get parsee() {\n        return parsee;\n    },\n    set parsee(_parsee) {\n        parsee = _parsee;\n    },\n    get parsea() {\n        return parsea;\n    },\n    set parsea(_parsea) {\n        parsea = _parsea;\n    },\n    get parsef() {\n        return parsef;\n    },\n    set parsef(_parsef) {\n        parsef = _parsef;\n    },\n    get parselabel() {\n        return parselabel;\n    },\n    set parselabel(_parselabel) {\n        parselabel = _parselabel;\n    },\n    get parsed() {\n        return parsed;\n    },\n    set parsed(_parsed) {\n        parsed = _parsed;\n    },\n    get parsec() {\n        return parsec;\n    },\n    set parsec(_parsec) {\n        parsec = _parsec;\n    },\n    get parsev() {\n        return parsev;\n    },\n    set parsev(_parsev) {\n        parsev = _parsev;\n    },\n    get main() {\n        return main;\n    },\n    set main(_main) {\n        main = _main;\n    },\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Deque = exports.Vector = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst util_1 = require(\"util\");\nconst readFile = (0, util_1.promisify)(fs_1.default.readFile);\n// checkmm uses a little bit of C++'s Standard Template Library.  Simulate it.\nconst isupper = (s) => {\n    if (/[^A-Z]/.test(s)) {\n        return false;\n    }\n    else {\n        return true;\n    }\n};\nconst isalnum = (s) => {\n    if (/[^a-zA-Z0-9]/.test(s)) {\n        return false;\n    }\n    else {\n        return true;\n    }\n};\nconst set_intersection = (s1, s2) => {\n    const s3 = new Set();\n    s1.forEach((value) => {\n        if (s2.has(value)) {\n            s3.add(value);\n        }\n    });\n    return s3;\n};\nclass Vector extends Array {\n}\nexports.Vector = Vector;\nclass Deque extends Array {\n}\nexports.Deque = Deque;\n// Simple function for comparing arrays (in C++ STL handles this automatically)\nconst arraysequal = (arr1, arr2) => {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let n = 0; n < arr1.length; ++n) {\n        if (arr1[n] !== arr2[n]) {\n            return false;\n        }\n    }\n    return true;\n};\nconst createstack = (arr) => {\n    let container = arr !== null && arr !== void 0 ? arr : [];\n    return {\n        push: (item) => {\n            container.push(item);\n        },\n        pop: () => container.pop(),\n        size: () => container.length,\n        top: () => container[container.length - 1],\n        truncate: (newLength) => {\n            container = container.slice(0, newLength);\n        },\n        at: (index) => container[index],\n        toArray: () => [...container],\n    };\n};\nconst std = {\n    isupper,\n    isalnum,\n    set_intersection,\n    arraysequal,\n    createstack,\n};\nexports.default = std;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createTokenArray = void 0;\nclass TokenArray extends Array {\n    constructor(...params) {\n        super(...params);\n    }\n    front() {\n        return this[this.length - 1];\n    }\n    empty() {\n        return !this.length;\n    }\n}\nconst createTokenArray = (...params) => {\n    return new TokenArray(...params);\n};\nexports.createTokenArray = createTokenArray;\n","module.exports = require(\"fs\");","module.exports = require(\"fs/promises\");","module.exports = require(\"path\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(13);\n"],"names":["__awaiter","this","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","Scope","Assertion","promises_1","path_1","std_1","tokens_1","std","default","createTokenArray","data","dataPosition","tokens","constants","Set","hypotheses","Map","variables","constructor","disjvars","expression","assertions","activevariables","activehyp","floatinghyp","scopes","Array","labelused","label","undefined","get","getfloatinghyp","vari","scope","loc","isactivevariable","str","has","isactivehyp","find","_str","isdvr","var1","var2","disjvar","ismmws","ch","islabeltoken","token","isalnum","ismathsymboltoken","includes","containsonlyupperorq","isupper","nexttoken","charAt","Error","charCodeAt","toString","readFile","filename","encoding","mmfilenamesalreadyencountered","readtokens","lastInFileInclusionStart","add","slice","_e","incomment","infileinclusion","newfilename","length","normalize","join","dirname","push","constructassertion","exp","assertion","set","varsused","reverse","hypvec","item2","hyp","second","first","unshift","item3","dset","from","set_intersection","index","index2","readexpression","stattype","terminator","empty","type","front","pop","makesubstitution","original","substmap","destination","item","getproofnumbers","proof","proofnumbers","num","justgotnum","addval","Number","MAX_SAFE_INTEGER","verifyassertionref","thlabel","reflabel","stack","size","base","substitutions","i","hypothesis","at","subst","dest","arraysequal","truncate","exp1","exp2","exp1vars","exp1item","exp2vars","exp2item","verifyregularproof","theorem","createstack","proofstep","verifycompressedproof","labels","mandhypt","labelt","savedsteps","top","parsep","newtheorem","_token","console","error","incomplete","parsee","newhyp","parsea","newaxiom","parsef","typeToken","variable","parselabel","parsed","dvars","parsec","listempty","parsev","main","argv","err","message","process","executedScript","__filename","reduce","acc","suffix","exitCode","_data","_dataPosition","_readFile","_std","_createTokenArray","_tokens","_constants","_hypotheses","_variables","_assertions","_scopes","_labelused","_getfloatinghyp","_isactivevariable","_isactivehyp","_isdvr","_ismmws","_islabeltoken","_ismathsymboltoken","_containsonlyupperorq","_nexttoken","_mmfilenamesalreadyencountered","_readtokens","_constructassertion","_readexpression","_makesubstitution","_getproofnumbers","_verifyassertionref","_verifyregularproof","_verifycompressedproof","_parsep","_parsee","_parsea","_parsef","_parselabel","_parsed","_parsec","_parsev","_main","Deque","Vector","fs_1","promisify","s","test","s1","s2","s3","forEach","arr1","arr2","n","arr","container","newLength","toArray","TokenArray","params","super","module","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}