(()=>{"use strict";var e={13:function(e,t,r){var o=this&&this.__awaiter||function(e,t,r,o){return new(r||(r=Promise))((function(n,s){function i(e){try{f(o.next(e))}catch(e){s(e)}}function a(e){try{f(o.throw(e))}catch(e){s(e)}}function f(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(i,a)}f((o=o.apply(e,t||[])).next())}))},n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Scope=t.Assertion=void 0;const s=n(r(292)),i=n(r(17)),a=n(r(896)),f=r(534);let h=a.default,c=f.createTokenArray,p="",l=0,u=c(),d=new Set,w=new Map,m=new Set;class g{constructor(){this.hypotheses=[],this.disjvars=new Set,this.expression=[]}}t.Assertion=g;let v=new Map;class y{constructor(){this.activevariables=new Set,this.activehyp=[],this.disjvars=[],this.floatinghyp=new Map}}t.Scope=y;let E=new Array,b=e=>void 0!==w.get(e)||void 0!==v.get(e),$=e=>{for(const t of E){const r=t.floatinghyp.get(e);if(void 0!==r)return r}return""},A=e=>{for(const t of E)if(t.activevariables.has(e))return!0;return!1},k=e=>{for(const t of E)if(t.activehyp.find((t=>e===t)))return!0;return!1},x=(e,t)=>{if(e===t)return!1;for(const r of E)for(const o of r.disjvars)if(o.has(e)&&o.has(t))return!0;return!1},_=e=>" "===e||"\n"===e||"\t"===e||"\f"===e||"\r"===e,S=e=>{for(const t of e)if(!h.isalnum(t)&&"."!==t&&"-"!==t&&"_"!==t)return!1;return!0},U=e=>!e.includes("$"),P=e=>{for(const t of e)if(!h.isupper(t)&&"?"!==t)return!1;return!0},T=()=>{let e,t="";for(;(e=p.charAt(l))&&_(e);)++l;for(;(e=p.charAt(l))&&!_(e);){if(e<"!"||e>"~")throw new Error("Invalid character read with code 0x"+e.charCodeAt(0).toString(16));t+=e,++l}return t},j=e=>o(void 0,void 0,void 0,(function*(){return s.default.readFile(e,{encoding:"utf-8"})})),M=new Set,q=(e,t=0)=>o(void 0,void 0,void 0,(function*(){if(M.has(e))return;M.add(e);try{p=p.slice(0,t)+(yield j(e))+p.slice(l),l=t}catch(t){throw new Error("Could not open "+e)}let r,o=!1,n=!1,s="";for(;(r=T()).length;)if(o){if("$)"===r){o=!1;continue}if(r.includes("$("))throw new Error("Characters $( found in a comment");if(r.includes("$)"))throw new Error("Characters $) found in a comment")}else if("$("!==r)if(n){if(s.length){if("$]"!==r)throw new Error("Didn't find closing file inclusion delimiter");yield q(s,t),n=!1,s="";continue}if(r.includes("$"))throw new Error("Filename "+r+" contains a $");s=i.default?i.default.normalize(i.default.join(i.default.dirname(e),r)):r}else"$["!==r?u.push(r):(n=!0,t=l-2);else o=!0;if(o)throw new Error("Unclosed comment");if(n)throw new Error("Unfinished file inclusion command")})),C=(e,t)=>{const r=new g;v.set(e,r),r.expression=t;const o=new Set;for(const e of t)m.has(e)&&o.add(e);for(const e of E.slice().reverse()){const t=e.activehyp;for(const e of t.slice().reverse()){const t=w.get(e);if(t.second&&o.has(t.first[1]))r.hypotheses.unshift(e);else if(!t.second){r.hypotheses.unshift(e);for(const e of t.first)m.has(e)&&o.add(e)}}}for(const e of E){const t=e.disjvars;for(const e of t){const t=Array.from(h.set_intersection(e,o));for(let e=0;e<t.length;++e)for(let o=e+1;o<t.length;++o)r.disjvars.add({first:t[e],second:t[o]})}}return r},F=(e,t,r)=>{if(u.empty())throw new Error("Unfinished $"+e+" statement "+t);const o=u.front();if(!d.has(o))throw new Error("First symbol in $"+e+" statement "+t+" is "+o+" which is not a constant");u.pop();const n=[o];let s;for(;!u.empty()&&(s=u.front())!==r;){if(u.pop(),!d.has(s)&&!$(s).length)throw new Error("In $"+e+" statement "+t+" token "+s+" found which is not a constant or variable in an active $f statement");n.push(s)}if(u.empty())throw new Error("Unfinished $"+e+" statement "+t);return u.pop(),n},I=(e,t)=>{let r=[];for(const o of e){const e=t.get(o);e?r=[...r,...e]:r.push(o)}return r},N=(e,t)=>{const r=[];let o=0,n=!1;for(const s of t)if(s<="T"){const t=s.charCodeAt(0)-("A".charCodeAt(0)-1);if(o>Number.MAX_SAFE_INTEGER/20||20*o>Number.MAX_SAFE_INTEGER-t)throw new Error("Overflow computing numbers in compressed proof of "+e);r.push(20*o+t),o=0,n=!0}else if(s<="Y"){const t=s.charCodeAt(0)-"T".charCodeAt(0);if(o>Number.MAX_SAFE_INTEGER/5||5*o>Number.MAX_SAFE_INTEGER-t)throw new Error("Overflow computing numbers in compressed proof of "+e);o=5*o+t,n=!1}else{if(!n)throw new Error("Stray Z found in compressed proof of "+e);r.push(0),n=!1}if(0!==o)throw new Error("Compressed proof of theorem "+e+" ends in unfinished number");return r},z=(e,t,r)=>{const o=v.get(t);if(r.size()<o.hypotheses.length)throw new Error("In proof of theorem "+e+" not enough items found on stack");const n=r.size()-o.hypotheses.length,s=new Map;for(let t=0;t<o.hypotheses.length;++t){const i=w.get(o.hypotheses[t]);if(i.second){if(i.first[0]!==r.at(n+t)[0])throw new Error("In proof of theorem "+e+" unification failed");const o=r.at(n+t).slice(1);s.set(i.first[1],o)}else{const o=I(i.first,s);if(!h.arraysequal(o,r.at(n+t)))throw new Error("In proof of theorem "+e+" unification failed")}}r.truncate(n);for(const t of o.disjvars){const r=s.get(t.first),o=s.get(t.second),n=new Set;for(const e of r)m.has(e)&&n.add(e);const i=new Set;for(const e of o)m.has(e)&&i.add(e);for(const t of n)for(const r of i)if(!x(t,r))throw new Error("In proof of theorem "+e+" disjoint variable restriction violated")}const i=I(o.expression,s);return r.push(i),r},D=(e,t,r)=>{let o=h.createstack();for(const t of r){const r=w.get(t);r?o.push(r.first):o=z(e,t,o)}if(1!==o.size())throw new Error("Proof of theorem "+e+" does not end with only one item on the stack");if(!h.arraysequal(o.at(0),t.expression))throw new Error("Proof of theorem "+e+" proves wrong statement")},O=(e,t,r,o)=>{let n=h.createstack();const s=t.hypotheses.length,i=s+r.length,a=[];for(const f of o)if(0!==f)if(f<=s)n.push(w.get(t.hypotheses[f-1]).first);else if(f<=i){const t=r[f-s-1],o=w.get(t);if(o){n.push(o.first);continue}n=z(e,t,n)}else{if(f>i+a.length)throw new Error("Number in compressed proof of "+e+" is too high");n.push(a[f-i-1])}else a.push(n.top());if(1!==n.size())throw new Error("Proof of theorem "+e+" does not end with only one item on the stack");if(!h.arraysequal(n.at(0),t.expression))throw new Error("Proof of theorem "+e+" proves wrong statement")},G=e=>{const t=F("p",e,"$="),r=C(e,t);if(u.empty())throw new Error("Unfinished $p statement "+e);if("("===u.front()){u.pop();const t=[];let o;for(;!u.empty()&&")"!==(o=u.front());){if(u.pop(),t.push(o),o===e)throw new Error("Proof of theorem "+e+" refers to itself");if(r.hypotheses.find((e=>e===o)))throw new Error("Compressed proof of theorem "+e+" has mandatory hypothesis "+o+" in label list");if(!v.has(o)&&!k(o))throw new Error("Proof of theorem "+e+" refers to "+o+" which is not an active statement")}if(u.empty())throw new Error("Unfinished $p statement "+e);u.pop();let n="";for(;!u.empty()&&"$."!==(o=u.front());)if(u.pop(),n+=o,!P(o))throw new Error("Bogus character found in compressed proof of "+e);if(u.empty())throw new Error("Unfinished $p statement "+e);if(!n.length)throw new Error("Theorem "+e+" has no proof");if(u.pop(),n.includes("?"))return void console.error("Warning: Proof of theorem "+e+" is incomplete");const s=N(e,n);O(e,r,t,s)}else{const t=[];let o,n=!1;for(;!u.empty()&&"$."!==(o=u.front());)if(u.pop(),t.push(o),"?"===o)n=!0;else{if(o===e)throw new Error("Proof of theorem "+e+" refers to itself");if(!v.has(o)&&!k(o))throw new Error("Proof of theorem "+e+" refers to "+o+" which is not an active statement")}if(u.empty())throw new Error("Unfinished $p statement "+e);if(!t.length)throw new Error("Theorem "+e+" has no proof");if(u.pop(),n)throw new Error("Warning: Proof of theorem "+e+" is incomplete");D(e,r,t)}},R=e=>{const t=F("e",e,"$.");w.set(e,{first:t,second:!1}),E[E.length-1].activehyp.push(e)},X=e=>{const t=F("a",e,"$.");C(e,t)},Z=e=>{if(u.empty())throw new Error("Unfinished $f statement"+e);const t=u.front();if(!d.has(t))throw new Error("First symbol in $f statement "+e+" is "+t+" which is not a constant");if(u.pop(),u.empty())throw new Error("Unfinished $f statement "+e);const r=u.front();if(!A(r))throw new Error("Second symbol in $f statement "+e+" is "+r+" which is not an active variable");if($(r).length)throw new Error("The variable "+r+" appears in a second $f statement "+e);if(u.pop(),u.empty())throw new Error("Unfinished $f statement"+e);if("$."!==u.front())throw new Error("Expected end of $f statement "+e+" but found "+u.front());u.pop();const o=[];o.push(t),o.push(r),w.set(e,{first:o,second:!0}),E[E.length-1].activehyp.push(e),E[E.length-1].floatinghyp.set(r,e)},V=e=>{if(d.has(e))throw new Error("Attempt to reuse constant "+e+" as a label");if(m.has(e))throw new Error("Attempt to reuse variable "+e+" as a label");if(b(e))throw new Error("Attempt to reuse label "+e);if(u.empty())throw new Error("Unfinished labeled statement");const t=u.pop();if("$p"===t)G(e);else if("$e"===t)R(e);else if("$a"===t)X(e);else{if("$f"!==t)throw new Error("Unexpected token "+t+" encountered");Z(e)}},W=()=>{const e=new Set;let t;for(;!u.empty()&&"$."!==(t=u.front());){if(u.pop(),!A(t))throw new Error("Token "+t+" is not an active variable, but was found in a $d statement");if(e.has(t))throw new Error("$d statement mentions "+t+" twice");e.add(t)}if(u.empty())throw new Error("Unterminated $d statement");if(e.size<2)throw new Error("Not enough items in $d statement");E[E.length-1].disjvars.push(e),u.pop()},B=()=>{if(E.length>1)throw new Error("$c statement occurs in inner block");let e,t=!0;for(;!u.empty()&&"$."!==(e=u.front());){if(u.pop(),t=!1,!U(e))throw new Error("Attempt to declare "+e+" as a constant");if(m.has(e))throw new Error("Attempt to redeclare variable "+e+" as a constant");if(b(e))throw new Error("Attempt to reuse label "+e+" as a constant");if(d.has(e))throw new Error("Attempt to redeclare constant "+e);d.add(e)}if(u.empty())throw new Error("Unterminated $c statement");if(t)throw new Error("Empty $c statement");u.pop()},Y=()=>{let e,t=!0;for(;!u.empty()&&"$."!==(e=u.front());){if(u.pop(),t=!1,!U(e))throw new Error("Attempt to declare "+e+" as a variable");if(d.has(e))throw new Error("Attempt to redeclare constant "+e+" as a variable");if(b(e))throw new Error("Attempt to reuse label "+e+" as a variable");if(A(e))throw new Error("Attempt to redeclare active variable "+e);m.add(e),E[E.length-1].activevariables.add(e)}if(u.empty())throw new Error("Unterminated $v statement");if(t)throw new Error("Empty $v statement");u.pop()},H=e=>o(void 0,void 0,void 0,(function*(){try{if(2!==e.length)return console.error("Syntax: checkmm <filename>"),1;for(yield q(e[1]),u.reverse(),E.push(new y);!u.empty();){const e=u.pop();if(S(e))V(e);else if("$d"===e)W();else if("${"===e)E.push(new y);else if("$}"===e){if(E.pop(),!E.length)throw new Error("$} without corresponding ${")}else if("$c"===e)B();else{if("$v"!==e)throw new Error("Unexpected token "+e+" encountered");Y()}}if(E.length>1)throw new Error("${ without corresponding $}");return 0}catch(e){return e instanceof Error?console.error(e.message):console.error(e),1}}));if(process){const e=process.argv.length>=2?process.argv[1]:"";[__filename,"/.bin/checkmm","/bin/checkmm","/cli.js","\\.bin\\checkmm","\\bin\\checkmm","\\cli.js"].reduce(((t,r)=>t||e.slice(-r.length)===r),!1)&&H(process.argv.slice(1)).then((e=>{process.exitCode=e}))}t.default={get data(){return p},set data(e){p=e},get dataPosition(){return l},set dataPosition(e){l=e},get readFile(){return j},set readFile(e){j=e},get std(){return h},set std(e){h=e},get createTokenArray(){return c},set createTokenArray(e){c=e},get tokens(){return u},set tokens(e){u=e},get constants(){return d},set constants(e){d=e},get hypotheses(){return w},set hypotheses(e){w=e},get variables(){return m},set variables(e){m=e},get assertions(){return v},set assertions(e){v=e},get scopes(){return E},set scopes(e){E=e},get labelused(){return b},set labelused(e){b=e},get getfloatinghyp(){return $},set getfloatinghyp(e){$=e},get isactivevariable(){return A},set isactivevariable(e){A=e},get isactivehyp(){return k},set isactivehyp(e){k=e},get isdvr(){return x},set isdvr(e){x=e},get ismmws(){return _},set ismmws(e){_=e},get islabeltoken(){return S},set islabeltoken(e){S=e},get ismathsymboltoken(){return U},set ismathsymboltoken(e){U=e},get containsonlyupperorq(){return P},set containsonlyupperorq(e){P=e},get nexttoken(){return T},set nexttoken(e){T=e},get mmfilenamesalreadyencountered(){return M},set mmfilenamesalreadyencountered(e){M=e},get readtokens(){return q},set readtokens(e){q=e},get constructassertion(){return C},set constructassertion(e){C=e},get readexpression(){return F},set readexpression(e){F=e},get makesubstitution(){return I},set makesubstitution(e){I=e},get getproofnumbers(){return N},set getproofnumbers(e){N=e},get verifyassertionref(){return z},set verifyassertionref(e){z=e},get verifyregularproof(){return D},set verifyregularproof(e){D=e},get verifycompressedproof(){return O},set verifycompressedproof(e){O=e},get parsep(){return G},set parsep(e){G=e},get parsee(){return R},set parsee(e){R=e},get parsea(){return X},set parsea(e){X=e},get parsef(){return Z},set parsef(e){Z=e},get parselabel(){return V},set parselabel(e){V=e},get parsed(){return W},set parsed(e){W=e},get parsec(){return B},set parsec(e){B=e},get parsev(){return Y},set parsev(e){Y=e},get main(){return H},set main(e){H=e}}},896:function(e,t,r){var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Deque=t.Vector=void 0;const n=o(r(147));(0,r(837).promisify)(n.default.readFile),t.Vector=class extends Array{},t.Deque=class extends Array{};const s={isupper:e=>!/[^A-Z]/.test(e),isalnum:e=>!/[^a-zA-Z0-9]/.test(e),set_intersection:(e,t)=>{const r=new Set;return e.forEach((e=>{t.has(e)&&r.add(e)})),r},arraysequal:(e,t)=>{if(e.length!==t.length)return!1;for(let r=0;r<e.length;++r)if(e[r]!==t[r])return!1;return!0},createstack:e=>{let t=null!=e?e:[];return{push:e=>{t.push(e)},pop:()=>t.pop(),size:()=>t.length,top:()=>t[t.length-1],truncate:e=>{t=t.slice(0,e)},at:e=>t[e],toArray:()=>[...t]}}};t.default=s},534:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createTokenArray=void 0;class r extends Array{constructor(...e){super(...e)}front(){return this[this.length-1]}empty(){return!this.length}}t.createTokenArray=(...e)=>new r(...e)},147:e=>{e.exports=require("fs")},292:e=>{e.exports=require("fs/promises")},17:e=>{e.exports=require("path")},837:e=>{e.exports=require("util")}},t={};!function r(o){var n=t[o];if(void 0!==n)return n.exports;var s=t[o]={exports:{}};return e[o].call(s.exports,s,s.exports,r),s.exports}(13)})();
//# sourceMappingURL=checkmm.js.map